-- Problem 72: Machine Learning Feature Engineering for Sales Prediction
-- Level: Complex
-- ============================================================

-- PROBLEM STATEMENT:
-- Write a query to create comprehensive feature sets for machine learning models to predict sales performance.

-- ============================================================
-- SOLUTION:
-- ============================================================

WITH BaseFeatures AS (SELECT p.productId, p.productName, c.categoryName, s.companyName AS supplierName, p.unitPrice, p.unitsInStock, p.reorderLevel, CASE WHEN p.discontinued = '1' THEN 1 ELSE 0 END AS isDiscontinued, LENGTH(p.productName) AS nameLength, CASE WHEN p.quantityPerUnit IS NOT NULL THEN 1 ELSE 0 END AS hasQuantityUnit FROM Product p JOIN Category c ON p.categoryId = c.categoryId JOIN Supplier s ON p.supplierId = s.supplierId), SalesFeatures AS (SELECT bf.productId, bf.productName, bf.categoryName, COUNT(od.orderDetailId) AS totalOrderLines, SUM(od.quantity) AS totalQuantitySold, AVG(od.quantity) AS avgQuantityPerOrder, SUM(od.quantity * od.unitPrice * (1 - od.discount)) AS totalRevenue, AVG(od.unitPrice) AS avgSoldPrice, AVG(od.discount) AS avgDiscount, COUNT(DISTINCT so.custId) AS uniqueCustomers, COUNT(DISTINCT so.employeeId) AS uniqueEmployees FROM BaseFeatures bf LEFT JOIN OrderDetail od ON bf.productId = od.productId LEFT JOIN SalesOrder so ON od.orderId = so.orderId GROUP BY bf.productId, bf.productName, bf.categoryName), TimeFeatures AS (SELECT sf.productId, sf.totalRevenue, COALESCE(MIN(so.orderDate), '1900-01-01') AS firstSaleDate, COALESCE(MAX(so.orderDate), '1900-01-01') AS lastSaleDate, COUNT(DISTINCT DATE_FORMAT(so.orderDate, '%Y-%m')) AS monthsWithSales, SUM(CASE WHEN so.orderDate >= DATE_SUB(CURDATE(), INTERVAL 90 DAY) THEN od.quantity ELSE 0 END) AS sales90Days, SUM(CASE WHEN so.orderDate >= DATE_SUB(CURDATE(), INTERVAL 30 DAY) THEN od.quantity ELSE 0 END) AS sales30Days FROM SalesFeatures sf LEFT JOIN OrderDetail od ON sf.productId = od.productId LEFT JOIN SalesOrder so ON od.orderId = so.orderId GROUP BY sf.productId, sf.totalRevenue), CategoryFeatures AS (SELECT c.categoryId, c.categoryName, COUNT(p.productId) AS categoryProductCount, AVG(p.unitPrice) AS categoryAvgPrice, SUM(sf.totalRevenue) AS categoryTotalRevenue FROM Category c JOIN Product p ON c.categoryId = p.categoryId LEFT JOIN SalesFeatures sf ON p.productId = sf.productId GROUP BY c.categoryId, c.categoryName), MLFeatureSet AS (SELECT bf.productId, bf.productName, bf.categoryName, bf.unitPrice, bf.unitsInStock, bf.reorderLevel, bf.isDiscontinued, bf.nameLength, bf.hasQuantityUnit, COALESCE(sf.totalOrderLines, 0) AS totalOrderLines, COALESCE(sf.totalQuantitySold, 0) AS totalQuantitySold, COALESCE(sf.avgQuantityPerOrder, 0) AS avgQuantityPerOrder, COALESCE(sf.totalRevenue, 0) AS totalRevenue, COALESCE(sf.avgSoldPrice, bf.unitPrice) AS avgSoldPrice, COALESCE(sf.avgDiscount, 0) AS avgDiscount, COALESCE(sf.uniqueCustomers, 0) AS uniqueCustomers, COALESCE(tf.monthsWithSales, 0) AS monthsWithSales, COALESCE(tf.sales90Days, 0) AS sales90Days, COALESCE(tf.sales30Days, 0) AS sales30Days, cf.categoryProductCount, cf.categoryAvgPrice, cf.categoryTotalRevenue, bf.unitPrice / NULLIF(cf.categoryAvgPrice, 0) AS priceVsCategoryAvg, COALESCE(sf.totalRevenue, 0) / NULLIF(cf.categoryTotalRevenue, 0) * 100 AS categoryRevenueShare FROM BaseFeatures bf LEFT JOIN SalesFeatures sf ON bf.productId = sf.productId LEFT JOIN TimeFeatures tf ON bf.productId = tf.productId JOIN Product p ON bf.productId = p.productId JOIN CategoryFeatures cf ON p.categoryId = cf.categoryId) SELECT productName, categoryName, unitPrice, totalRevenue, sales30Days, sales90Days, uniqueCustomers, priceVsCategoryAvg, categoryRevenueShare, CASE WHEN totalRevenue > (SELECT AVG(totalRevenue) FROM MLFeatureSet) THEN 1 ELSE 0 END AS highPerformer FROM MLFeatureSet ORDER BY totalRevenue DESC;
