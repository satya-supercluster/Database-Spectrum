-- Problem 62: Dynamic Customer Segmentation with Behavioral Scoring
-- Level: Complex
-- ============================================================

-- PROBLEM STATEMENT:
-- Write a complex query to create dynamic customer segments based on multiple behavioral factors and scoring algorithms.

-- ============================================================
-- SOLUTION:
-- ============================================================

WITH CustomerBehavior AS (SELECT c.custId, c.companyName, COUNT(DISTINCT s.orderId) AS orderFrequency, AVG(DATEDIFF(s.orderDate, LAG(s.orderDate) OVER (PARTITION BY c.custId ORDER BY s.orderDate))) AS avgOrderInterval, SUM(od.quantity * od.unitPrice * (1 - od.discount)) AS totalSpent, AVG(od.quantity * od.unitPrice * (1 - od.discount)) AS avgOrderValue, COUNT(DISTINCT p.categoryId) AS categoryDiversity, MAX(s.orderDate) AS lastOrderDate, MIN(s.orderDate) AS firstOrderDate FROM Customer c JOIN SalesOrder s ON c.custId = s.custId JOIN OrderDetail od ON s.orderId = od.orderId JOIN Product p ON od.productId = p.productId GROUP BY c.custId, c.companyName), ScoringMetrics AS (SELECT custId, companyName, orderFrequency, avgOrderInterval, totalSpent, avgOrderValue, categoryDiversity, DATEDIFF(CURDATE(), lastOrderDate) AS daysSinceLastOrder, DATEDIFF(lastOrderDate, firstOrderDate) AS customerLifespan, CASE WHEN orderFrequency >= 10 THEN 5 WHEN orderFrequency >= 5 THEN 4 WHEN orderFrequency >= 3 THEN 3 WHEN orderFrequency >= 1 THEN 2 ELSE 1 END AS frequencyScore, CASE WHEN totalSpent >= 5000 THEN 5 WHEN totalSpent >= 2000 THEN 4 WHEN totalSpent >= 1000 THEN 3 WHEN totalSpent >= 500 THEN 2 ELSE 1 END AS monetaryScore, CASE WHEN DATEDIFF(CURDATE(), lastOrderDate) <= 30 THEN 5 WHEN DATEDIFF(CURDATE(), lastOrderDate) <= 90 THEN 4 WHEN DATEDIFF(CURDATE(), lastOrderDate) <= 180 THEN 3 WHEN DATEDIFF(CURDATE(), lastOrderDate) <= 365 THEN 2 ELSE 1 END AS recencyScore FROM CustomerBehavior), FinalSegmentation AS (SELECT custId, companyName, frequencyScore, monetaryScore, recencyScore, (frequencyScore + monetaryScore + recencyScore) AS totalScore, CASE WHEN (frequencyScore + monetaryScore + recencyScore) >= 13 THEN 'Champions' WHEN (frequencyScore + monetaryScore + recencyScore) >= 10 AND recencyScore >= 3 THEN 'Loyal Customers' WHEN recencyScore >= 4 AND frequencyScore <= 2 THEN 'New Customers' WHEN monetaryScore >= 4 AND recencyScore <= 2 THEN 'At Risk' WHEN recencyScore <= 2 AND frequencyScore <= 2 THEN 'Lost Customers' ELSE 'Regular Customers' END AS segment FROM ScoringMetrics) SELECT segment, COUNT(*) AS customerCount, AVG(totalScore) AS avgScore, MIN(totalScore) AS minScore, MAX(totalScore) AS maxScore FROM FinalSegmentation GROUP BY segment ORDER BY avgScore DESC;
